<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Minecraft CPU vs GPU vs TPU</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- PIXEL FONT -->
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Press Start 2P', cursive;
    background: linear-gradient(180deg, #5da130 0%, #3b7a1a 100%);
    color: white;
    min-height: 100vh;
    padding: 20px;
    overflow-x: hidden;
}

.container {
    max-width: 1400px;
    margin: auto;
    position: relative;
    z-index: 1; /* above floating blocks */
}

header {
    text-align: center;
    margin-bottom: 30px;
}

h1 {
    color: #6cff2a;
    text-shadow: 4px 4px 0px #1b4d0f;
    font-size: 2em;
}

.subtitle {
    color: #d9ffb3;
    font-size: 0.7em;
}

/* BLOCK STYLE */
.processor-card, .controls, .info-card {
    background: #8b5a2b;
    border: 4px solid #5a3a1a;
    border-radius: 6px;
    padding: 20px;
    box-shadow: inset -4px -4px 0px #6b4423;
}

.demo-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 25px;
    margin-top: 20px;
}

.processor-card.cpu { border-color: #c0392b; }
.processor-card.gpu { border-color: #27ae60; }
.processor-card.tpu { border-color: #8e44ad; }

.processor-name {
    font-size: 1em;
    text-shadow: 2px 2px 0px #000;
}

.card-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 10px;
    align-items: center;
}

.time-display {
    background: #000;
    padding: 6px 10px;
    border: 2px solid #6cff2a;
    font-size: 0.7em;
}

/* CANVAS */
.canvas-container {
    background: #000;
    border: 4px solid #333;
    border-radius: 0;
    margin-bottom: 10px;
    position: relative;
}

canvas {
    width: 100%;
    height: 250px;
    image-rendering: pixelated;
    display: block;
}

.status {
    position: absolute;
    bottom: 6px;
    left: 6px;
    background: #222;
    border: 2px solid #555;
    padding: 5px 8px;
    font-size: 0.6em;
}

/* CONTROLS */
.controls {
    margin-bottom: 25px;
}

.control-group label {
    font-size: 0.7em;
}

.slider {
    width: 100%;
    margin-top: 10px;
}

.slider::-webkit-slider-thumb {
    background: #6cff2a;
}

.button-group {
    margin-top: 20px;
    display: flex;
    gap: 15px;
}

button {
    font-family: 'Press Start 2P', cursive;
    padding: 12px;
    font-size: 0.6em;
    border-radius: 0;
    border: 3px solid black;
    cursor: pointer;
    box-shadow: inset -3px -3px 0 rgba(0,0,0,0.4);
}

.btn-start { background: #27ae60; }
.btn-start:hover { background: #2ecc71; }

.btn-reset { background: #c0392b; }
.btn-reset:hover { background: #e74c3c; }

button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* INFO CARDS */
.info-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 20px;
    margin-top: 30px;
}

.info {
    font-size: 0.6em;
}

.info-card h3 {
    font-size: 0.8em;
}

.info-card p {
    font-size: 0.6em;
}

/* FLOATING MINECRAFT-STYLE BLOCKS */
.floating-block {
    position: fixed;
    width: 48px;
    height: 48px;
    z-index: 0;
    border: 3px solid #000;
    box-shadow: 0 4px 0 rgba(0,0,0,0.5);
    background:
        linear-gradient(to bottom, #3fa703 0 35%, #2b7a02 35% 40%, #8b5a2b 40% 100%);
    image-rendering: pixelated;
    animation: floatBlock 10s ease-in-out infinite;
    opacity: 0.9;
}

/* Individual positions & timings */
.block1 { top: 8%;  left: 4%;  animation-duration: 14s; }
.block2 { top: 18%; right: 6%; animation-duration: 11s; }
.block3 { bottom: 12%; left: 12%; animation-duration: 16s; }
.block4 { bottom: 18%; right: 14%; animation-duration: 13s; }

@keyframes floatBlock {
    0%   { transform: translateY(0) translateX(0) rotate(0deg); }
    25%  { transform: translateY(-15px) translateX(10px) rotate(-2deg); }
    50%  { transform: translateY(-5px) translateX(-10px) rotate(2deg); }
    75%  { transform: translateY(-18px) translateX(5px) rotate(-1deg); }
    100% { transform: translateY(0) translateX(0) rotate(0deg); }
}
</style>
</head>

<body>

<!-- Floating Minecraft-style grass blocks -->
<div class="floating-block block1"></div>
<div class="floating-block block2"></div>
<div class="floating-block block3"></div>
<div class="floating-block block4"></div>

<div class="container">

<header>
    <h1>‚õè CPU vs GPU vs TPU ‚õè</h1>
    <p class="subtitle">Minecraft Parallel Processing Demo</p>
</header>

<div class="controls">
    <div class="control-group">
        <label>World Resolution: <span id="resolutionValue">64x64</span></label>
        <input type="range" class="slider" id="resolutionSlider" min="32" max="128" step="16" value="64">
    </div>

    <div class="button-group">
        <button class="btn-start" id="startBtn">‚ñ∂ Start Mining</button>
        <button class="btn-reset" id="resetBtn">‚õè Reset World</button>
    </div>
</div>

<div class="demo-grid">

    <div class="processor-card cpu">
        <div class="card-header">
            <div class="processor-name">‚öí CPU Miner</div>
            <div class="time-display" id="cpuTime">0.00s</div>
        </div>
        <div class="canvas-container">
            <canvas id="cpuCanvas"></canvas>
            <div class="status" id="cpuStatus">Ready</div>
        </div>
        <div class="info">Slow mining ‚Äî one block at a time.</div>
    </div>

    <div class="processor-card gpu">
        <div class="card-header">
            <div class="processor-name">üíé GPU Crafter</div>
            <div class="time-display" id="gpuTime">0.00s</div>
        </div>
        <div class="canvas-container">
            <canvas id="gpuCanvas"></canvas>
            <div class="status" id="gpuStatus">Ready</div>
        </div>
        <div class="info">Fast mining ‚Äî multiple rows at once.</div>
    </div>

    <div class="processor-card tpu">
        <div class="card-header">
            <div class="processor-name">üß† TPU Redstone Core</div>
            <div class="time-display" id="tpuTime">0.00s</div>
        </div>
        <div class="canvas-container">
            <canvas id="tpuCanvas"></canvas>
            <div class="status" id="tpuStatus">Ready</div>
        </div>
        <div class="info">Instant mining ‚Äî entire chunk at once.</div>
    </div>

</div>

</div>

<script>
// Controls & elements
var resolutionSlider = document.getElementById('resolutionSlider');
var resolutionValue  = document.getElementById('resolutionValue');
var startBtn         = document.getElementById('startBtn');
var resetBtn         = document.getElementById('resetBtn');

var cpuCanvas = document.getElementById('cpuCanvas');
var gpuCanvas = document.getElementById('gpuCanvas');
var tpuCanvas = document.getElementById('tpuCanvas');

var cpuCtx = cpuCanvas.getContext('2d');
var gpuCtx = gpuCanvas.getContext('2d');
var tpuCtx = tpuCanvas.getContext('2d');

var cpuTime   = document.getElementById('cpuTime');
var gpuTime   = document.getElementById('gpuTime');
var tpuTime   = document.getElementById('tpuTime');

var cpuStatus = document.getElementById('cpuStatus');
var gpuStatus = document.getElementById('gpuStatus');
var tpuStatus = document.getElementById('tpuStatus');

var resolution   = 64;
var isRunning    = false;
var cancelRender = false;

function setCanvasSize() {
    cpuCanvas.width = resolution;
    cpuCanvas.height = resolution;
    gpuCanvas.width = resolution;
    gpuCanvas.height = resolution;
    tpuCanvas.width = resolution;
    tpuCanvas.height = resolution;
}
setCanvasSize();

resolutionSlider.addEventListener('input', function(e){
    resolution = parseInt(e.target.value);
    resolutionValue.textContent = resolution + "x" + resolution;
    setCanvasSize();
    resetAll();
});

function resetAll(){
    cpuCtx.fillStyle = '#000';
    cpuCtx.fillRect(0, 0, resolution, resolution);
    gpuCtx.fillStyle = '#000';
    gpuCtx.fillRect(0, 0, resolution, resolution);
    tpuCtx.fillStyle = '#000';
    tpuCtx.fillRect(0, 0, resolution, resolution);

    cpuTime.textContent = '0.00s';
    gpuTime.textContent = '0.00s';
    tpuTime.textContent = '0.00s';

    cpuStatus.textContent = 'Ready';
    gpuStatus.textContent = 'Ready';
    tpuStatus.textContent = 'Ready';
}

// Same gradient color for all three
function generatePixelColor(x, y){
    var hue = (x / resolution * 360 + y / resolution * 180) % 360;
    var saturation = 70;
    var lightness = 50;
    return 'hsl(' + hue + ', ' + saturation + '%, ' + lightness + '%)';
}

// HSL to RGB helper (for TPU imageData)
function hslToRgb(h, s, l) {
    var r, g, b;

    if (s === 0) {
        r = g = b = l;
    } else {
        function hue2rgb(p, q, t) {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

// CPU: sequential
function renderCPU(){
    return new Promise(resolve=>{
        cpuStatus.textContent = "Mining...";
        var x = 0, y = 0;
        var start = performance.now();

        function step(){
            if (cancelRender) { resolve(); return; }

            if (y >= resolution) {
                cpuTime.textContent = ((performance.now()-start)/1000).toFixed(2) + "s";
                cpuStatus.textContent = "Done!";
                resolve();
                return;
            }

            cpuCtx.fillStyle = generatePixelColor(x, y);
            cpuCtx.fillRect(x, y, 1, 1);

            x++;
            if (x >= resolution) { x = 0; y++; }

            setTimeout(step, 0);
        }
        step();
    });
}

// GPU: batched rows
function renderGPU(){
    return new Promise(resolve=>{
        gpuStatus.textContent = "Mining...";
        var y = 0;
        var rowsPerBatch = 4;
        var start = performance.now();

        function step(){
            if (cancelRender) { resolve(); return; }

            if (y >= resolution) {
                gpuTime.textContent = ((performance.now()-start)/1000).toFixed(2) + "s";
                gpuStatus.textContent = "Done!";
                resolve();
                return;
            }

            for (var dy = 0; dy < rowsPerBatch && y+dy < resolution; dy++){
                for (var x = 0; x < resolution; x++){
                    gpuCtx.fillStyle = generatePixelColor(x, y+dy);
                    gpuCtx.fillRect(x, y+dy, 1, 1);
                }
            }

            y += rowsPerBatch;
            setTimeout(step, 10);
        }
        step();
    });
}

// TPU: full image in one go (same gradient)
function renderTPU(){
    return new Promise(resolve=>{
        tpuStatus.textContent = "Mining...";
        var start = performance.now();

        var imageData = tpuCtx.createImageData(resolution, resolution);
        var data = imageData.data;

        for (var yy = 0; yy < resolution; yy++) {
            for (var xx = 0; xx < resolution; xx++) {
                var color = generatePixelColor(xx, yy);
                var match = color.match(/hsl\((\d+\.?\d*),\s*(\d+\.?\d*)%,\s*(\d+\.?\d*)%\)/);
                if (match) {
                    var h = parseFloat(match[1]) / 360;
                    var s = parseFloat(match[2]) / 100;
                    var l = parseFloat(match[3]) / 100;
                    var rgb = hslToRgb(h, s, l);

                    var idx = (yy * resolution + xx) * 4;
                    data[idx]     = rgb[0];
                    data[idx + 1] = rgb[1];
                    data[idx + 2] = rgb[2];
                    data[idx + 3] = 255;
                }
            }
        }

        setTimeout(function(){
            if (!cancelRender) {
                tpuCtx.putImageData(imageData, 0, 0);
                tpuTime.textContent = ((performance.now() - start)/1000).toFixed(2) + "s";
                tpuStatus.textContent = "Done!";
            }
            resolve();
        }, 50);
    });
}

// Start button
startBtn.onclick = function(){
    if (isRunning) return;
    cancelRender = false;
    isRunning = true;

    startBtn.disabled = true;
    resetBtn.disabled = true;
    resolutionSlider.disabled = true;

    resetAll();

    Promise.all([
        renderCPU(),
        renderGPU(),
        renderTPU()
    ]).then(function(){
        if (!cancelRender) {
            isRunning = false;
            startBtn.disabled = false;
            resetBtn.disabled = false;
            resolutionSlider.disabled = false;
        }
    });
};

// Reset button: cancels and clears immediately
resetBtn.onclick = function(){
    cancelRender = true;
    isRunning = false;
    startBtn.disabled = false;
    resetBtn.disabled = false;
    resolutionSlider.disabled = false;
    resetAll();
};
</script>
</body>
</html>
